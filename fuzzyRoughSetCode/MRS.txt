import numpy as np
from sklearn.cluster import KMeans
class MRS:## incremental tolerance fuzzy tough set
    def __init__(self):## the use of this tolerance still not decide yet
        pass
         
    def fit(self, X, Y, cat = [], X_var = []):
        self.Y = Y
        self.X = X
        self.cat = cat
        if len(X_var) == 0 or len(X_var) != X.shape[1]:
            self.X_var = []
            for attr in range(self.X.shape[1]):
                if attr in cat:
                    self.X_var.append(0)
                else:
                    self.X_var.append(np.var(self.X[:,attr]))
        else:
            self.X_var = X_var
        self.minimum_rule_finding()     
    def predict(self,newX):
        best_decision = -1
        max_mf = 0
        sim_dict = {}
        for rules_decision in self.all_rule:
            rules = self.all_rule[rules_decision]
            for rule in rules:
                sim = 1
                for attr in range(self.X.shape[1]):
                    if attr in self.cat:
                        if newX[attr] == rule[attr]:
                            sim = min(sim,1)
                        else:
                            sim = 0
                    else:
                        relation = np.exp(-(newX[attr] - rule[attr])**2/(2*self.X_var[attr]))
                        if np.isnan(relation):##just in case variance is 0, then it make sense that they are the same 
                            relation = 1
                        sim  = min(sim,relation)
                sim_dict[tuple(rule)] = sim        
        for decision in np.unique(self.Y):
            m_f_to_low = 0
            m_f_to_up = 0
            for rules_decision in self.all_rule:#range(self.X.shape[0]):
                if rules_decision != decision:
                    rules = self.all_rule[rules_decision]
                    for rule in rules:
                        sim = sim_dict[tuple(rule)]
                        if m_f_to_low < 1 - sim:
                            m_f_to_low = 1 - sim
                if rules_decision == decision:
                    rules = self.all_rule[rules_decision]
                    for rule in rules:
                        sim = sim_dict[tuple(rule)]
                        if m_f_to_up < sim:
                            m_f_to_up= sim
            mf = m_f_to_low +m_f_to_up
            if mf > max_mf:
                max_mf = mf
                best_decision = decision
        return best_decision,max_mf
    def minimum_rule_finding(self):
        self.all_rule = {}     
        for decision in np.unique(self.Y):
            index_d = np.where(self.Y == decision)[0]  
            U_X = self.X[index_d]
            center = U_X
            if len(self.cat) == 0:
                if U_X.shape[0] > 10: 
                        kmodel = KMeans(n_clusters = max(int(U_X.shape[0]/10),10), n_jobs = 8)
                        kmodel.fit(U_X)
                        center = kmodel.cluster_centers_
            self.all_rule[decision] = center
            
    